---
title: Redux source code ç ”ç©¶
slug: redux-source-code
image: ./images/image-1.png
date: 2020-01-28
author: liyo
---

ğŸš€ğŸš€ğŸš€ğŸš€ é€™æ¬¡è¶è‘—éå¹´æœŸé–“æŠŠReduxå¥½å¥½çš„ç ”ç©¶äº†ä¸€é, ç‰¹æ­¤ç´€éŒ„

### 1. why use redux
+ 1-1. React local State
+ 1-2. flux
+ 1-3. Redux solve some problem

### 2. redux source code
+ 2-1. combineReducer
+ 2-2. createStore
+ 2-3. applyMiddleware
+ 2-4. compose
+ 2-5. middleware (redux-thunk, redux-promise)

<br />

# 1. why use Redux

### 1-1. React local State
Reactä¸­, çˆ¶å…ƒä»¶å¯ä»¥åˆ©ç”¨ props å‚³å€¼çµ¦å­å…ƒä»¶, è€Œå­å…ƒä»¶è¦å‚³å€¼çµ¦çˆ¶å…ƒä»¶æ™‚, å¯ä»¥ä½¿ç”¨çˆ¶å…ƒä»¶ç”¨ props å‚³ä¸‹ä¾†çš„æ–¹æ³•, ä¿®æ”¹åˆ°çˆ¶å…ƒä»¶æœ¬èº«çš„ state , è·Ÿ Vue çš„é›™å‘ç¶å®šä¸ä¸€æ¨£, åœ¨æŸäº›æƒ…æ³ä¸‹, å–®å–®åªä½¿ç”¨ React æä¾›çš„ props å’Œ state å¯èƒ½æœƒé€ æˆå…ƒä»¶å½¼æ­¤ä¹‹é–“é—œä¿‚çš„è¤‡é›œåŒ–, å¦‚æœä¸åŒçˆ¶å…ƒä»¶åº•ä¸‹çš„å­å…ƒä»¶, è¦å…±äº«è³‡æ–™æ™‚, é€™æ™‚å…±äº«è³‡æ–™å°±å¿…é ˆæ”¾åœ¨åŸæœ¬çˆ¶å…ƒä»¶å±¤ç´šçš„ä¸Šä¸€å±¤, å†ç¶“ç”± props é€ç´šå‚³ä¸‹å», å‡è¨­ä¸­é–“çš„çˆ¶å…ƒä»¶æœ¬èº«ä¸¦ä¸åœ¨ä¹é€™é …è³‡æ–™, å¼·åŠ ä¸Šå»çš„ props å°±é¡¯å¾—æœ‰é»å¤šé¤˜, ç•¶åº•å±¤å­å…ƒä»¶é–“å…±äº«çš„è³‡æ–™å¤šèµ·ä¾†, é‚£éº¼åœ¨ä¸­é–“çˆ¶å…ƒä»¶çš„"è¡¨é¢"å°±æœƒæœ‰å¤ªå¤š props çš„ç”¢ç”Ÿ, ä¹Ÿä¸èƒ½ç¢ºå®šåˆ°åº•å“ªå€‹å­å…ƒä»¶ç²å¾—çš„è³‡æ–™ç‚ºæœ€æ–°

<br />

### 1-2. flux
flux æ˜¯ç•¶åˆ fb æ‰€æå‡ºçš„ä¸€ç¨®æ–°å–®å‘è³‡æ–™æµæƒ³æ³•, ç•¶åˆæ˜¯è·ŸMVCåšå°æ¯”, æ¯”èµ· MVC ä¾†èªª, flux çš„è³‡æ–™æµæ›´æœ‰åš´è¬¹æ€§, å› ç‚ºå–®å‘çš„é—œä¿‚æ‰€ä»¥è³‡æ–™çš„æ›´æ”¹æœƒå¤šäº†å¹¾å±¤æ‰‹æ®µ, flux æŠŠè³‡æ–™é›†ä¸­èµ·ä¾†ç‚ºStore, è¦ä¿®æ”¹è£¡é¢çš„è³‡æ–™åªèƒ½ä½¿ç”¨ Store æ‰€æä¾›çš„ dispatch æ–¹æ³•, è€Œç•«é¢æ¸²æŸ“å‰‡æ˜¯è¦è¨‚é–±  Store ä¸­æ„Ÿèˆˆè¶£çš„è³‡æ–™(æœƒä½¿ç•«é¢è®Šå‹•çš„è³‡æ–™), æœƒæœ‰å€‹ callback ä¾†é€²è¡Œç•«é¢çš„ re-render (å¯èƒ½æ˜¯æ›´æ–°æœ¬èº«å…ƒä»¶çš„ state ç‚º store çš„ç‰¹å®šè³‡æ–™ä¾†é”åˆ°ç•«é¢æ›´æ–°), ç•¶ store ä¸­è³‡æ–™è®Šå‹•æ™‚å‰‡æœƒå‘¼å«é€™å€‹ callback

<br />

### 1-3. Redux solve some problem
Redux ç‚ºåŸºæ–¼ flux æå‡ºçš„æ–°æƒ³æ³•(Reducer + flux = Red + ux), Redux ä½œè€…ä¹Ÿæœ‰æå‡ºå¤šé … Redux çš„å„ªé»:
* å¯é æ¸¬æ€§çš„è³‡æ–™æ›´æ–°, è³‡æ–™æ›´æ–°åªèƒ½ä»¥å‚³é Action çš„æ–¹å¼, é€é store æä¾›çš„ dispatch å‚³é€² Reducer ä¸­
* è³‡æ–™çš„ä¸­å¤®ç®¡ç†åŒ–
* Time-travel debugging, å¯ä»¥å›åˆ°è³‡æ–™æ›´æ–°å‰çš„å‹•ä½œ
* é¿å… hot-reload å…ƒä»¶ä¸Šçš„è³‡æ–™åˆé‡è¼‰äº† (componentæ›´æ–°å°è‡´åŸå…ˆ state ä¸è¦‹, æ¯”è¼ƒåƒæ˜¯é–‹ç™¼ä¸­çš„å•é¡Œ)
, ä½† Redux ä½œè€… Dan ä¹Ÿæœ‰æåˆ°, è¦ä¸è¦ç”¨ Redux å› å°ˆæ¡ˆè€Œç•°, React æˆ–å…¶ä»–é‚„æœ‰æä¾›å¾ˆå¤šæ–¹å¼ (props/state, React Context, React Hook, GraphQL, Apollo, React Suspense) , ä½†é€™åˆæ˜¯å¦ä¸€å€‹æ•…äº‹äº†

<br />

# 2. how to use redux

### 2-3. combineReducer

å¾åŸç¢¼ä¸­å¯ä»¥çœ‹å‡º, Redux æä¾›çš„ combineReducer æ–¹æ³•ä¸»è¦æ˜¯ä»¥ä¸€å€‹æ›´å¤§çš„ Reducer ä¾†åŒ…ä½è¦çµ„åˆçš„ Reducer , ä»¥æ­¤é”æˆçµ„åˆçš„æ•ˆæœ, æ¯å€‹å° Reducer å„è‡ªè² è²¬è‡ªå·±å°æ‡‰åˆ° store çš„è³‡æ–™, ç•¶æ¯å€‹å° Reducer éƒ½æŠŠè‡ªå·±çš„è³‡æ–™è™•ç†å®Œ, æ›´æ–°å¾Œçš„æ–° state tree å°±å‡ºä¾†äº†, combineReducerä¸»è¦æ˜¯å›å‚³ä¸€å€‹function(å¯ä»¥çœ‹æˆæ˜¯å¤§Reducer), store è£¡çš„è³‡æ–™åŠ action æœƒè¢«ç•¶åƒæ•¸å‚³é€², é¦–å…ˆæœƒæŠŠæ‰€æœ‰å° Reducer è’é›†èµ·ä¾†, ä¹‹å¾Œä¾åºä¾†æ›´æ–° state tree , ç›´åˆ°æœ€å¾Œä¸€å€‹å° Reducer å®Œæˆä»–çš„å·¥ä½œ

<div className="code">

```javascript
/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */

export default function combineReducers(reducers) {
/** å‚³é€²ä¾†çš„ reducers é€šå¸¸æœƒè£æˆ object 
* å¦‚ {ninjaReducer: ninjaReducer, masterReducer: masterReducer}
* å› ç‚º key èˆ‡åƒæ•¸åä¸€æ¨£, å¯ä»¥ç”¨ES6å¯«æˆ {ninjaReducer, masterReducer}
* finalReducers ä¸»è¦æ˜¯ç¢ºèªå‚³é€²ä¾†çš„æ˜¯ä¸æ˜¯æ­£å¸¸çš„ Reducer
*/
  const reducerKeys = Object.keys(reducers)
  const finalReducers = {} 

// æª¢æŸ¥éƒ¨åˆ†, é †ä¾¿æŠŠæ‰€æœ‰å° Reducer è’é›†èµ·ä¾† ======
  for (let i = 0; i < reducerKeys.length; i++) {
    const key = reducerKeys[i]

    if (process.env.NODE_ENV !== 'production') {
      if (typeof reducers[key] === 'undefined') {
        warning(`No reducer provided for key "${key}"`)
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key]
    }
  }
  const finalReducerKeys = Object.keys(finalReducers)

// è­¦å‘Šéƒ¨åˆ† ======
  let unexpectedKeyCache
  if (process.env.NODE_ENV !== 'production') {
    unexpectedKeyCache = {}
  }

  let shapeAssertionError
  try {
    assertReducerShape(finalReducers)
  } catch (e) {
    shapeAssertionError = e
  }

//combination å…¶å¯¦å°±æ˜¯å€‹å¤§ Reducer , (state, action) => state
  return function combination(state = {}, action) {
    if (shapeAssertionError) {
      throw shapeAssertionError
    }

    if (process.env.NODE_ENV !== 'production') {
      const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache)
      if (warningMessage) {
        warning(warningMessage)
      }
    }

    let hasChanged = false

    // ä¾åºä¾†æ›´æ–° state tree (nextState), ç›´åˆ°æœ€å¾Œä¸€å€‹å° Reducer å®Œæˆä»–çš„å·¥ä½œ
    const nextState = {}
    for (let i = 0; i < finalReducerKeys.length; i++) {
      const key = finalReducerKeys[i]
      const reducer = finalReducers[key]
	// æ¯å€‹å° Reducer å„è‡ªè² è²¬è‡ªå·±å°æ‡‰åˆ° store çš„è³‡æ–™
      const previousStateForKey = state[key]
      const nextStateForKey = reducer(previousStateForKey, action)

      if (typeof nextStateForKey === 'undefined') {
        const errorMessage = getUndefinedStateErrorMessage(key, action)
        throw new Error(errorMessage)
      }
	// æª¢æŸ¥é€™å€‹å° Reducer æœ‰æ²’æœ‰å° state tree é€ æˆè®Šå‹•
      nextState[key] = nextStateForKey
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey
    }
    return hasChanged ? nextState : state
  }
}

```

</div>

### 2-4 createStore
createStore ç‚º Redux çš„æ ¸å¿ƒ, é€™å€‹æ–¹æ³•æœƒæŠŠ state tree ç•¶æˆç§æœ‰åŒ–, å°å¤–åªé–‹æ”¾è‡ªå·±çš„æ–¹æ³•(store.dispatch)ä¾†ä¿®æ”¹, è£¡é¢æœƒå­˜è‘— state tree èˆ‡ listener ä½‡åˆ—(è³‡æ–™è®Šå‹•æ™‚è©²åšå“ªäº›äº‹é€šçŸ¥å¤–é¢çš„å…ƒä»¶), ç•¶ç„¶ä¹Ÿæ˜¯æä¾›è‡ªå·±çš„æ–¹æ³•(store.subscribe)ä¾†çµ¦å°å¤–è¨‚é–±é€™å€‹ store

<div className="code">

```javascript

/**
 * Creates a Redux store that holds the state tree.
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} [enhancer] The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */

/** ç•¶åŒæ™‚æœ‰å¥½å¤šå€‹ reducer æ™‚, å°‡ combineReducers ä»¥ reducer åƒæ•¸å‚³å…¥æ˜¯ä½ çš„æœ€ä½³é¸æ“‡, 
* combineReducers(ä½ çš„reducer1, ä½ çš„reducer2, ä½ çš„reducer3)
*
* preloadedState ç‚º state çš„åˆå§‹å€¼, å¯ä»¥ä¸å‚³, ä¸­é–“æœƒè‡ªå·±èª¿æ•´åƒæ•¸ä½ç½®
*
* enhancer æœ‰é»åƒæ˜¯æ“´å……åŠŸèƒ½, ç•¶åŒæ™‚æœ‰å¥½å¤šå€‹ middleware(æ“´å……åŠŸèƒ½)æ™‚, 
* å°‡ applyMiddleware ä»¥ enhancer åƒæ•¸å‚³å…¥æ˜¯ä½ çš„æœ€ä½³é¸æ“‡,
* applyMiddleware(ä½ çš„middleware1, ä½ çš„middleware2, ä½ çš„middleware3)
*
* createStore æœƒå›å‚³ä¸€å€‹ç”± function çµ„èµ·ä¾†çš„ object , 
* åŒ…å«å°è³‡æ–™çš„å–å€¼(getState), è¨‚é–±æ©Ÿåˆ¶(subscribe), ä¿®æ”¹è³‡æ–™(dispatch), 
* èˆ‡æ¯”è¼ƒå°‘ç”¨åˆ°çš„é–‹ç™¼è€…åŠŸèƒ½(replaceReducer, observable)
*/
export default function createStore(reducer, preloadedState, enhancer) {
// createStore å¯ä»¥è·³é preloadedState åªå‚³2å€‹åƒæ•¸, é€™è£¡æœƒåšèª¿æ•´
  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState
    preloadedState = undefined
  }
/** å¦‚æœæœ‰è£æ“´å……åŠŸèƒ½, é‚£éº¼ç›´æ¥å»é‚£é‚ŠåŸ·è¡Œ, 
* enhancer å›å‚³çš„æ±è¥¿èˆ‡ createStore ä¸€æ¨£, 
* å¸¸ç”¨çš„æ“´å……åŠŸèƒ½ç›®çš„æ˜¯ç‚ºäº†ä¿®æ”¹ store çš„è³‡æ–™ä¿®æ”¹æ©Ÿåˆ¶ dispatch, 
* å…¶ä»–çš„æ–¹æ³•éƒ½ä¸å‹•(èˆ‡ createStore çš„å›å‚³ä¸€æ¨£, æœ‰é»å·å¤©æ›æ—¥çš„æ„Ÿè¦º), 
* å› æ­¤ createStore æœ¬èº«ä¹Ÿæœƒè¢«å‚³é€²å» 
*/
  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.')
    }
    // é–‹å§‹å·å¤©æ›æ—¥
    return enhancer(createStore)(reducer, preloadedState)
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.')
  }

  let currentReducer = reducer
  let currentState = preloadedState
  let currentListeners = []
  let nextListeners = currentListeners
  let isDispatching = false

/** nextListeners æœ‰é»åƒæ˜¯ currentListeners çš„ç·©å­˜ Buffer, 
* åŸ·è¡Œå®ŒèˆŠçš„ listen ä½‡åˆ—æ‰æœƒåŒæ­¥é€² currentListeners ,
* é€™è£¡åªæ˜¯åœ¨ç¢ºä¿æ¯æ¬¡ä¿®æ”¹å‰ä¸€å®šæ˜¯å…¨æ–°çš„ object ,è€Œä¸æ˜¯èˆŠçš„åƒç…§
*/
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice()
    }
  }

  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */
  // Store çš„ Getter
  function getState() {
    return currentState
  }

  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */
  
  /**
  * Store çš„è¨‚é–±æ©Ÿåˆ¶, é€™è£¡çš„æº–å‚™çš„ listener ä¸»è¦æ˜¯åœ¨ dispatch é‚£é‚Šè®Šå‹•å®Œè³‡æ–™å¾ŒåŸ·è¡Œ, 
  * å›å‚³å–æ¶ˆè¨‚é–±çš„æ–¹æ³•, æœ‰é»åƒä¸‹è¼‰è»Ÿé«”éƒ½æœƒé™„è´ˆçš„ uninstall ä¸€æ¨£
  */
  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected listener to be a function.')
    }

    let isSubscribed = true
    // ä¿®æ”¹å‰ç¢ºä¿æ–°æ•¸çµ„
    ensureCanMutateNextListeners()
    nextListeners.push(listener)

    return function unsubscribe() {
      if (!isSubscribed) {
        return
      }

      isSubscribed = false
      // ä¿®æ”¹å‰ç¢ºä¿æ–°æ•¸çµ„
      ensureCanMutateNextListeners()
      // å–æ¶ˆè¨‚é–±å°±å¾ listener ä½‡åˆ—ä¸­æ¸…é™¤
      const index = nextListeners.indexOf(listener)
      nextListeners.splice(index, 1)
    }
  }

  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing â€œwhat changedâ€. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */
  /*
  * dispatch ç‚ºæ“´å……åŠŸèƒ½(enhance)æ”¹é€ çš„å°è±¡, åƒæ˜¯redux-thunk, redux-promiseé€™äº›çš„,
  * ä»–å€‘æœƒ"å»¶å¾Œ"åŸç”Ÿ dispatch åŸ·è¡Œçš„æ™‚é–“é»ä¸€é»é»,
  * é€™äº› middleware æœƒç”¨ Redux æä¾›çš„ compose æ–¹æ³•,
  * èˆ‡åŸç”Ÿ dispatch ä½œèåˆ, å¦‚ ninjaMiddleware(hunterMiddleware(åŸç”Ÿdispatch()))
  */
  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error(
        'Actions must be plain objects. ' +
        'Use custom middleware for async actions.'
      )
    }

    if (typeof action.type === 'undefined') {
      throw new Error(
        'Actions may not have an undefined "type" property. ' +
        'Have you misspelled a constant?'
      )
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.')
    }
// å‚³é€²å¤§ Reducer è™•ç†è³‡æ–™, dispatch æœ¬èº«ä¸è² è²¬è™•ç† state, åªæ˜¯åœ¨æ¯æ¬¡"å¯èƒ½"ä¿®æ”¹äº† state å¾Œ, æŠŠæ‰€æœ‰ listen å«å‡ºä¾†åŸ·è¡Œä¸€é
    try {
      isDispatching = true
      currentState = currentReducer(currentState, action)
    } finally {
      isDispatching = false
    }
/* åœ¨å®£å‘Šæ™‚é †ä¾¿åŒæ­¥ nextListeners åˆ° currentListeners è£¡é¢
* ä¹‹å¾Œå…¨éƒ¨ listener ä¾åºåŸ·è¡Œ,
* listener è£¡ callback é€šå¸¸æœƒæŠŠ store.getState èˆ‡ React.setState ç¶ä¸€èµ·,
* æ•ˆèƒ½æ‡‰è©²æ˜¯ä¸æœƒå·®å¾ˆå¤š, é›–ç„¶å¯èƒ½æœ‰äº› listener æ ¹æœ¬ä¸åœ¨ä¹æ­¤æ¬¡ä¿®æ”¹
*/
    const listeners = currentListeners = nextListeners
    for (let i = 0; i < listeners.length; i++) {
      const listener = listeners[i]
      listener()
    }

    return action
  }

  // ä¸‹é¢çš„æ–¹æ³•å¤§å¤šåœ¨é–‹ç™¼æ™‚æ‰æœƒç”¨åˆ° ======

  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.')
    }

    currentReducer = nextReducer
    dispatch({ type: ActionTypes.INIT })
  }

  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */
  function observable() {
    const outerSubscribe = subscribe
    return {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe(observer) {
        if (typeof observer !== 'object') {
          throw new TypeError('Expected the observer to be an object.')
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState())
          }
        }

        observeState()
        const unsubscribe = outerSubscribe(observeState)
        return { unsubscribe }
      },

      [$$observable]() {
        return this
      }
    }
  }

  // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.
  dispatch({ type: ActionTypes.INIT })

  return {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [$$observable]: observable
  }
}

```

</div>

### 2-5. applyMiddleware
applyMiddleware ç‚ºåŸºæ–¼ createStore ä¹‹ä¸Šåšçš„ä¿®æ”¹, å¯ä»¥å¾ applyMiddleware çš„å›å‚³çœ‹å‡ºé™¤äº† dispatch ä»¥å¤–çš„åŠŸèƒ½éƒ½è·ŸåŸå…ˆ createStore æä¾›çš„ä¸€æ¨£, ç¶“é middleware å±¤çš„ dispatch å°‡èƒ½å¤ æ¥å—ä¸åŒå‹æ…‹çš„ action åƒæ•¸

<div className="code">

```javascript
/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */
export default function applyMiddleware(...middlewares) {
  return (createStore) => (reducer, preloadedState, enhancer) => {
    // å‰µå»ºåŸç”Ÿ store ä¾†ç²å–é™¤ dispatch ä»¥å¤–åŠŸèƒ½
    const store = createStore(reducer, preloadedState, enhancer)
    let dispatch = store.dispatch
    let chain = []

    const middlewareAPI = {
      getState: store.getState,
      dispatch: (action) => dispatch(action)
    }
    /* 
    * é€™è£¡æœƒæŠŠ middleware çš„ç¬¬ä¸€å€‹åƒæ•¸è§£æ‰, 
    * é€šå¸¸æœƒæ˜¯ ({getState, dispatch}) => (next) => (action) => {...} çš„å‹æ…‹,
    * é€™è£¡å°±æœƒæŠŠ middlewareAPI ä»£å…¥({getState, dispatch})
    */
    chain = middlewares.map(middleware => middleware(middlewareAPI))
    /* åœ¨åŸç”Ÿ dispatch æ–¹æ³•å¤–åŠ äº† middleware å±¤, å¾ˆåƒexpressçš„middleware
    * compose(ninjaMiddle, hunterMiddle) æœƒè®Šæˆ 
    * (...arg) => ninjaMiddle( hunterMiddle ( ...arg ) )
    *
    * compose(ninjaMiddle, hunterMiddle)(store.dispatch) å°±æ˜¯ 
    * ninjaMiddle( hunterMiddle (store.dispatch) )
    * è€Œä¾†åˆ°é€™çš„ middleware çš„ç¬¬ä¸€å±¤åƒæ•¸å·²ç¶“è¢«è§£æ‰åªå‰©ä¸‹ next => action => {...}
    * æ‰€ä»¥ store.dispatch æœƒè¢«ç•¶æˆ next å‚³åˆ°"æœ€å¾Œä¸€å€‹ middleware"è£¡,
    * è€Œæ¯ä¸€å€‹ middleware ä¸­çš„ next å‰‡æ˜¯ä¸‹ä¸€å€‹ middleware çš„ dispatch éƒ¨åˆ†
    */
    dispatch = compose(...chain)(store.dispatch)

    return {
      ...store,
      dispatch
    }
  }
}

```

</div>

### 2-6. compose
compose è² è²¬çµ„åˆåŒé¡å‹çš„å‡½å¼, åŸç†å¾ˆç°¡å–®, ä½¿ç”¨ reduce å°‡å‡½å¼éè¿´çš„ç–ŠåŠ è€Œå·² ,æ¯å€‹ function éƒ½é æœŸæœƒæ¥æ”¶ä¸€å€‹åƒæ•¸, å®ƒçš„å›å‚³å€¼å°‡æœƒä½œç‚ºåœ¨å®ƒå·¦é‚Šçš„ function çš„è®Šæ•¸, compose(ninja, hunter)å°±æœƒæ˜¯ hunter çš„å›å‚³å€¼æœƒè¢«ç•¶æˆåƒæ•¸å‚³å…¥ ninja è£¡ => ninja(hunter(...arg))

<div className="code">

```javascript

/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */

export default function compose(...funcs) {
  if (funcs.length === 0) {
    return arg => arg
  }

  if (funcs.length === 1) {
    return funcs[0]
  }

  return funcs.reduce((a, b) => (...args) => a(b(...args)))
}

```

</div>

2-7. middleware

* Redux-thunk

<div className="code">

```javascript
function createThunkMiddleware(extraArgument) {
  return ({ dispatch, getState }) => (next) => (action) => {
    if (typeof action === 'function') {
      return action(dispatch, getState, extraArgument);
    }

    return next(action);
  };
}

const thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;

export default thunk;

```

</div>

* Redux-promise

<div className="code">

```javascript

import isPromise from 'is-promise';
import { isFSA } from 'flux-standard-action';

export default function promiseMiddleware({ dispatch }) {
  return next => action => {
    if (!isFSA(action)) {
      return isPromise(action) ? action.then(dispatch) : next(action);
    }

    return isPromise(action.payload)
      ? action.payload
          .then(result => dispatch({ ...action, payload: result }))
          .catch(error => {
            dispatch({ ...action, payload: error, error: true });
            return Promise.reject(error);
          })
      : next(action);
  };
}

```

</div>
